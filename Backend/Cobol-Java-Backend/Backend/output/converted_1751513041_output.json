{
  "status": "success",
  "convertedCode": {
    "Entity": {
      "FileName": "AccountRecord.cs",
      "Path": "Models/",
      "content": "using System;\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\n\nnamespace CicsModernization.Domain.Entities\n{\n    public class AccountRecord\n    {\n        [Key]\n        [Column(\"ACC_NUMBER\")]\n        public long AccountNumber { get; set; }\n\n        [Required]\n        [Column(\"ACC_HOLDER_NAME\")]\n        [StringLength(50)]\n        public string AccountHolderName { get; set; }\n\n        [Column(\"ACC_TYPE\")]\n        [StringLength(2)]\n        public string AccountType { get; set; }\n\n        [Column(\"ACC_BALANCE\")]\n        public decimal AccountBalance { get; set; }\n\n        [Column(\"ACC_STATUS\")]\n        [StringLength(1)]\n        public string AccountStatus { get; set; }\n\n        [Column(\"ACC_OPEN_DATE\")]\n        public DateTime AccountOpenDate { get; set; }\n\n        [Column(\"ACC_LAST_ACTIVITY\")]\n        public DateTime AccountLastActivity { get; set; }\n    }\n}"
    },
    "Repository": {
      "FileName": "IAccountRepository.cs",
      "Path": "Repositories/Interfaces/",
      "content": "using System.Collections.Generic;\nusing System.Threading.Tasks;\nusing CicsModernization.Domain.Entities;\n\nnamespace CicsModernization.Repositories.Interfaces\n{\n    public interface IAccountRepository\n    {\n        Task<IEnumerable<AccountRecord>> GetAllAccountsAsync();\n        Task<AccountRecord> GetAccountByIdAsync(long accountNumber);\n        Task AddAccountAsync(AccountRecord account);\n        Task UpdateAccountAsync(AccountRecord account);\n        Task DeleteAccountAsync(long accountNumber);\n    }\n}"
    },
    "RepositoryImpl": {
      "FileName": "AccountRepository.cs",
      "Path": "Repositories/",
      "content": "using System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing CicsModernization.Data;\nusing CicsModernization.Domain.Entities;\nusing CicsModernization.Repositories.Interfaces;\n\nnamespace CicsModernization.Repositories\n{\n    public class AccountRepository : IAccountRepository\n    {\n        private readonly ApplicationDbContext _context;\n\n        public AccountRepository(ApplicationDbContext context)\n        {\n            _context = context;\n        }\n\n        public async Task<IEnumerable<AccountRecord>> GetAllAccountsAsync()\n        {\n            return await _context.Accounts.ToListAsync();\n        }\n\n        public async Task<AccountRecord> GetAccountByIdAsync(long accountNumber)\n        {\n            return await _context.Accounts.FindAsync(accountNumber);\n        }\n\n        public async Task AddAccountAsync(AccountRecord account)\n        {\n            await _context.Accounts.AddAsync(account);\n            await _context.SaveChangesAsync();\n        }\n\n        public async Task UpdateAccountAsync(AccountRecord account)\n        {\n            _context.Accounts.Update(account);\n            await _context.SaveChangesAsync();\n        }\n\n        public async Task DeleteAccountAsync(long accountNumber)\n        {\n            var account = await _context.Accounts.FindAsync(accountNumber);\n            if (account != null)\n            {\n                _context.Accounts.Remove(account);\n                await _context.SaveChangesAsync();\n            }\n        }\n    }\n}"
    },
    "Service": {
      "FileName": "IAccountService.cs",
      "Path": "Services/Interfaces/",
      "content": "using System.Collections.Generic;\nusing System.Threading.Tasks;\nusing CicsModernization.Domain.Entities;\n\nnamespace CicsModernization.Services.Interfaces\n{\n    public interface IAccountService\n    {\n        Task<IEnumerable<AccountRecord>> GetAllAccountsAsync();\n        Task<AccountRecord> GetAccountByIdAsync(long accountNumber);\n        Task AddAccountAsync(AccountRecord account);\n        Task UpdateAccountAsync(AccountRecord account);\n        Task DeleteAccountAsync(long accountNumber);\n    }\n}"
    },
    "ServiceImpl": {
      "FileName": "AccountService.cs",
      "Path": "Services/",
      "content": "using System.Collections.Generic;\nusing System.Threading.Tasks;\nusing CicsModernization.Domain.Entities;\nusing CicsModernization.Repositories.Interfaces;\nusing CicsModernization.Services.Interfaces;\n\nnamespace CicsModernization.Services\n{\n    public class AccountService : IAccountService\n    {\n        private readonly IAccountRepository _accountRepository;\n\n        public AccountService(IAccountRepository accountRepository)\n        {\n            _accountRepository = accountRepository;\n        }\n\n        public async Task<IEnumerable<AccountRecord>> GetAllAccountsAsync()\n        {\n            return await _accountRepository.GetAllAccountsAsync();\n        }\n\n        public async Task<AccountRecord> GetAccountByIdAsync(long accountNumber)\n        {\n            return await _accountRepository.GetAccountByIdAsync(accountNumber);\n        }\n\n        public async Task AddAccountAsync(AccountRecord account)\n        {\n            await _accountRepository.AddAccountAsync(account);\n        }\n\n        public async Task UpdateAccountAsync(AccountRecord account)\n        {\n            await _accountRepository.UpdateAccountAsync(account);\n        }\n\n        public async Task DeleteAccountAsync(long accountNumber)\n        {\n            await _accountRepository.DeleteAccountAsync(accountNumber);\n        }\n    }\n}"
    },
    "Controller": {
      "FileName": "AccountController.cs",
      "Path": "Controllers/",
      "content": "using System.Collections.Generic;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\nusing CicsModernization.Domain.Entities;\nusing CicsModernization.Services.Interfaces;\n\nnamespace CicsModernization.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class AccountController : ControllerBase\n    {\n        private readonly IAccountService _accountService;\n\n        public AccountController(IAccountService accountService)\n        {\n            _accountService = accountService;\n        }\n\n        [HttpGet]\n        public async Task<ActionResult<IEnumerable<AccountRecord>>> GetAllAccounts()\n        {\n            var accounts = await _accountService.GetAllAccountsAsync();\n            return Ok(accounts);\n        }\n\n        [HttpGet(\"{accountNumber}\")]\n        public async Task<ActionResult<AccountRecord>> GetAccountById(long accountNumber)\n        {\n            var account = await _accountService.GetAccountByIdAsync(accountNumber);\n            if (account == null)\n            {\n                return NotFound();\n            }\n            return Ok(account);\n        }\n\n        [HttpPost]\n        public async Task<ActionResult> AddAccount([FromBody] AccountRecord account)\n        {\n            await _accountService.AddAccountAsync(account);\n            return CreatedAtAction(nameof(GetAccountById), new { accountNumber = account.AccountNumber }, account);\n        }\n\n        [HttpPut(\"{accountNumber}\")]\n        public async Task<ActionResult> UpdateAccount(long accountNumber, [FromBody] AccountRecord account)\n        {\n            if (accountNumber != account.AccountNumber)\n            {\n                return BadRequest();\n            }\n            await _accountService.UpdateAccountAsync(account);\n            return NoContent();\n        }\n\n        [HttpDelete(\"{accountNumber}\")]\n        public async Task<ActionResult> DeleteAccount(long accountNumber)\n        {\n            await _accountService.DeleteAccountAsync(accountNumber);\n            return NoContent();\n        }\n    }\n}"
    },
    "DbContext": {
      "FileName": "ApplicationDbContext.cs",
      "Path": "Data/",
      "content": "using Microsoft.EntityFrameworkCore;\nusing CicsModernization.Domain.Entities;\n\nnamespace CicsModernization.Data\n{\n    public class ApplicationDbContext : DbContext\n    {\n        public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options)\n            : base(options)\n        {\n        }\n\n        public DbSet<AccountRecord> Accounts { get; set; }\n\n        protected override void OnModelCreating(ModelBuilder modelBuilder)\n        {\n            base.OnModelCreating(modelBuilder);\n\n            modelBuilder.Entity<AccountRecord>()\n                .ToTable(\"ACCOUNTS\")\n                .HasKey(a => a.AccountNumber);\n        }\n    }\n}"
    },
    "Program": {
      "FileName": "Program.cs",
      "Path": "./",
      "content": "using Microsoft.AspNetCore.Builder;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing CicsModernization.Data;\nusing CicsModernization.Repositories;\nusing CicsModernization.Repositories.Interfaces;\nusing CicsModernization.Services;\nusing CicsModernization.Services.Interfaces;\n\nvar builder = WebApplication.CreateBuilder(args);\n\n// Add services to the container\nbuilder.Services.AddControllers();\n\n// Configure Entity Framework with MySQL\nvar connectionString = builder.Configuration.GetConnectionString(\"DefaultConnection\");\nbuilder.Services.AddDbContext<ApplicationDbContext>(options =>\n    options.UseMySql(connectionString, ServerVersion.AutoDetect(connectionString)));\n\n// Register repositories and services\nbuilder.Services.AddScoped<IAccountRepository, AccountRepository>();\nbuilder.Services.AddScoped<IAccountService, AccountService>();\n\nvar app = builder.Build();\n\n// Configure the HTTP request pipeline\nif (app.Environment.IsDevelopment())\n{\n    app.UseDeveloperExceptionPage();\n}\n\napp.UseHttpsRedirection();\napp.UseAuthorization();\napp.MapControllers();\n\n// Ensure database is created\nusing (var scope = app.Services.CreateScope())\n{\n    var dbContext = scope.ServiceProvider.GetRequiredService<ApplicationDbContext>();\n    dbContext.Database.EnsureCreated();\n}\n\napp.Run();"
    },
    "Startup": {
      "FileName": "Startup.cs",
      "Path": "./",
      "content": "// Startup class is not needed in .NET 8 as Program.cs handles configuration"
    },
    "AppSettings": {
      "FileName": "appsettings.json",
      "Path": "./",
      "content": "{\n  \"ConnectionStrings\": {\n    \"DefaultConnection\": \"Server=localhost;Port=3306;Database=BankingDB;User=root;Password=password;SslMode=none\"\n  },\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Information\",\n      \"Microsoft.AspNetCore\": \"Warning\"\n    }\n  },\n  \"AllowedHosts\": \"*\"\n}"
    },
    "AppSettingsDev": {
      "FileName": "appsettings.Development.json",
      "Path": "./",
      "content": "{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Debug\",\n      \"Microsoft.AspNetCore\": \"Debug\"\n    }\n  }\n}"
    },
    "ProjectFile": {
      "FileName": "Project.csproj",
      "Path": "./",
      "content": "<Project Sdk=\"Microsoft.NET.Sdk.Web\">\n\n  <PropertyGroup>\n    <TargetFramework>net8.0</TargetFramework>\n  </PropertyGroup>\n\n  <ItemGroup>\n    <PackageReference Include=\"Microsoft.EntityFrameworkCore\" Version=\"8.0.0\" />\n    <PackageReference Include=\"Microsoft.EntityFrameworkCore.Design\" Version=\"8.0.0\" />\n    <PackageReference Include=\"Pomelo.EntityFrameworkCore.MySql\" Version=\"8.0.0\" />\n    <PackageReference Include=\"Microsoft.Extensions.Logging\" Version=\"8.0.0\" />\n    <PackageReference Include=\"AutoMapper\" Version=\"12.0.0\" />\n  </ItemGroup>\n\n</Project>"
    },
    "Dependencies": {
      "content": "NuGet packages and .NET dependencies needed: Microsoft.EntityFrameworkCore, Microsoft.EntityFrameworkCore.Design, Pomelo.EntityFrameworkCore.MySql, Microsoft.Extensions.Logging, AutoMapper"
    }
  },
  "conversionNotes": "The COBOL code was converted to a .NET 8 application using Entity Framework Core for database operations. The business logic for account management and transaction processing was preserved. The architecture follows clean architecture principles with a layered approach.",
  "potentialIssues": [
    "Ensure the MySQL server is properly configured and accessible.",
    "Validate that all business rules are correctly implemented in the C# code."
  ],
  "unitTests": "using System.Collections.Generic;\nusing System.Threading.Tasks;\nusing Moq;\nusing NUnit.Framework;\nusing CicsModernization.Domain.Entities;\nusing CicsModernization.Repositories.Interfaces;\nusing CicsModernization.Services;\n\nnamespace CicsModernization.Tests.Services\n{\n    [TestFixture]\n    public class AccountServiceTests\n    {\n        private Mock<IAccountRepository> _accountRepositoryMock;\n        private AccountService _accountService;\n\n        [SetUp]\n        public void Setup()\n        {\n            _accountRepositoryMock = new Mock<IAccountRepository>();\n            _accountService = new AccountService(_accountRepositoryMock.Object);\n        }\n\n        [Test]\n        public async Task GetAllAccountsAsync_ShouldReturnAllAccounts()\n        {\n            // Arrange\n            var accounts = new List<AccountRecord>\n            {\n                new AccountRecord { AccountNumber = 1, AccountHolderName = \"John Doe\", AccountBalance = 1000 },\n                new AccountRecord { AccountNumber = 2, AccountHolderName = \"Jane Doe\", AccountBalance = 2000 }\n            };\n            _accountRepositoryMock.Setup(repo => repo.GetAllAccountsAsync()).ReturnsAsync(accounts);\n\n            // Act\n            var result = await _accountService.GetAllAccountsAsync();\n\n            // Assert\n            Assert.AreEqual(2, result.Count);\n            _accountRepositoryMock.Verify(repo => repo.GetAllAccountsAsync(), Times.Once);\n        }\n\n        [Test]\n        public async Task GetAccountByIdAsync_ExistingAccount_ShouldReturnAccount()\n        {\n            // Arrange\n            var account = new AccountRecord { AccountNumber = 1, AccountHolderName = \"John Doe\", AccountBalance = 1000 };\n            _accountRepositoryMock.Setup(repo => repo.GetAccountByIdAsync(1)).ReturnsAsync(account);\n\n            // Act\n            var result = await _accountService.GetAccountByIdAsync(1);\n\n            // Assert\n            Assert.IsNotNull(result);\n            Assert.AreEqual(1, result.AccountNumber);\n            _accountRepositoryMock.Verify(repo => repo.GetAccountByIdAsync(1), Times.Once);\n        }\n\n        [Test]\n        public async Task GetAccountByIdAsync_NonExistingAccount_ShouldReturnNull()\n        {\n            // Arrange\n            _accountRepositoryMock.Setup(repo => repo.GetAccountByIdAsync(1)).ReturnsAsync((AccountRecord)null);\n\n            // Act\n            var result = await _accountService.GetAccountByIdAsync(1);\n\n            // Assert\n            Assert.IsNull(result);\n            _accountRepositoryMock.Verify(repo => repo.GetAccountByIdAsync(1), Times.Once);\n        }\n\n        [Test]\n        public async Task AddAccountAsync_ShouldAddAccount()\n        {\n            // Arrange\n            var account = new AccountRecord { AccountNumber = 3, AccountHolderName = \"New User\", AccountBalance = 500 };\n\n            // Act\n            await _accountService.AddAccountAsync(account);\n\n            // Assert\n            _accountRepositoryMock.Verify(repo => repo.AddAccountAsync(account), Times.Once);\n        }\n\n        [Test]\n        public async Task UpdateAccountAsync_ShouldUpdateAccount()\n        {\n            // Arrange\n            var account = new AccountRecord { AccountNumber = 1, AccountHolderName = \"Updated User\", AccountBalance = 1500 };\n\n            // Act\n            await _accountService.UpdateAccountAsync(account);\n\n            // Assert\n            _accountRepositoryMock.Verify(repo => repo.UpdateAccountAsync(account), Times.Once);\n        }\n\n        [Test]\n        public async Task DeleteAccountAsync_ShouldDeleteAccount()\n        {\n            // Arrange\n            var accountNumber = 1;\n\n            // Act\n            await _accountService.DeleteAccountAsync(accountNumber);\n\n            // Assert\n            _accountRepositoryMock.Verify(repo => repo.DeleteAccountAsync(accountNumber), Times.Once);\n        }\n    }\n}",
  "unitTestDetails": {
    "unitTestCode": "using System.Collections.Generic;\nusing System.Threading.Tasks;\nusing Moq;\nusing NUnit.Framework;\nusing CicsModernization.Domain.Entities;\nusing CicsModernization.Repositories.Interfaces;\nusing CicsModernization.Services;\n\nnamespace CicsModernization.Tests.Services\n{\n    [TestFixture]\n    public class AccountServiceTests\n    {\n        private Mock<IAccountRepository> _accountRepositoryMock;\n        private AccountService _accountService;\n\n        [SetUp]\n        public void Setup()\n        {\n            _accountRepositoryMock = new Mock<IAccountRepository>();\n            _accountService = new AccountService(_accountRepositoryMock.Object);\n        }\n\n        [Test]\n        public async Task GetAllAccountsAsync_ShouldReturnAllAccounts()\n        {\n            // Arrange\n            var accounts = new List<AccountRecord>\n            {\n                new AccountRecord { AccountNumber = 1, AccountHolderName = \"John Doe\", AccountBalance = 1000 },\n                new AccountRecord { AccountNumber = 2, AccountHolderName = \"Jane Doe\", AccountBalance = 2000 }\n            };\n            _accountRepositoryMock.Setup(repo => repo.GetAllAccountsAsync()).ReturnsAsync(accounts);\n\n            // Act\n            var result = await _accountService.GetAllAccountsAsync();\n\n            // Assert\n            Assert.AreEqual(2, result.Count);\n            _accountRepositoryMock.Verify(repo => repo.GetAllAccountsAsync(), Times.Once);\n        }\n\n        [Test]\n        public async Task GetAccountByIdAsync_ExistingAccount_ShouldReturnAccount()\n        {\n            // Arrange\n            var account = new AccountRecord { AccountNumber = 1, AccountHolderName = \"John Doe\", AccountBalance = 1000 };\n            _accountRepositoryMock.Setup(repo => repo.GetAccountByIdAsync(1)).ReturnsAsync(account);\n\n            // Act\n            var result = await _accountService.GetAccountByIdAsync(1);\n\n            // Assert\n            Assert.IsNotNull(result);\n            Assert.AreEqual(1, result.AccountNumber);\n            _accountRepositoryMock.Verify(repo => repo.GetAccountByIdAsync(1), Times.Once);\n        }\n\n        [Test]\n        public async Task GetAccountByIdAsync_NonExistingAccount_ShouldReturnNull()\n        {\n            // Arrange\n            _accountRepositoryMock.Setup(repo => repo.GetAccountByIdAsync(1)).ReturnsAsync((AccountRecord)null);\n\n            // Act\n            var result = await _accountService.GetAccountByIdAsync(1);\n\n            // Assert\n            Assert.IsNull(result);\n            _accountRepositoryMock.Verify(repo => repo.GetAccountByIdAsync(1), Times.Once);\n        }\n\n        [Test]\n        public async Task AddAccountAsync_ShouldAddAccount()\n        {\n            // Arrange\n            var account = new AccountRecord { AccountNumber = 3, AccountHolderName = \"New User\", AccountBalance = 500 };\n\n            // Act\n            await _accountService.AddAccountAsync(account);\n\n            // Assert\n            _accountRepositoryMock.Verify(repo => repo.AddAccountAsync(account), Times.Once);\n        }\n\n        [Test]\n        public async Task UpdateAccountAsync_ShouldUpdateAccount()\n        {\n            // Arrange\n            var account = new AccountRecord { AccountNumber = 1, AccountHolderName = \"Updated User\", AccountBalance = 1500 };\n\n            // Act\n            await _accountService.UpdateAccountAsync(account);\n\n            // Assert\n            _accountRepositoryMock.Verify(repo => repo.UpdateAccountAsync(account), Times.Once);\n        }\n\n        [Test]\n        public async Task DeleteAccountAsync_ShouldDeleteAccount()\n        {\n            // Arrange\n            var accountNumber = 1;\n\n            // Act\n            await _accountService.DeleteAccountAsync(accountNumber);\n\n            // Assert\n            _accountRepositoryMock.Verify(repo => repo.DeleteAccountAsync(accountNumber), Times.Once);\n        }\n    }\n}",
    "testDescription": "The unit tests for the AccountService class cover all CRUD operations, ensuring that the service interacts correctly with the repository layer. The tests include scenarios for retrieving all accounts, retrieving a specific account by ID, adding a new account, updating an existing account, and deleting an account. Mocking is used to isolate the service from the repository, allowing for focused testing of the service logic.",
    "coverage": [
      "Retrieving all accounts",
      "Retrieving an account by ID",
      "Adding a new account",
      "Updating an existing account",
      "Deleting an account"
    ],
    "businessRuleTests": [
      "Ensure account retrieval returns correct data",
      "Validate account addition and update operations",
      "Verify account deletion logic"
    ]
  },
  "functionalTests": {
    "functionalTests": [
      {
        "id": "FT1",
        "title": "Verify account retrieval by account number",
        "steps": [
          "Authenticate user session.",
          "Send a GET request to /api/account/{accountNumber} with a valid account number.",
          "Check the response status code is 200 OK.",
          "Verify the response body contains the correct account details."
        ],
        "expectedResult": "The account details are retrieved successfully with status code 200.",
        "businessRule": "User sessions must be authenticated and authorized before any operation."
      },
      {
        "id": "FT2",
        "title": "Verify account creation",
        "steps": [
          "Authenticate user session.",
          "Send a POST request to /api/account with a valid account payload.",
          "Check the response status code is 201 Created.",
          "Verify the response contains the location header with the new account URL.",
          "Retrieve the account using the location URL and verify the account details."
        ],
        "expectedResult": "The account is created successfully and can be retrieved with correct details.",
        "businessRule": "Audit logging is mandatory for all transactions to ensure compliance."
      },
      {
        "id": "FT3",
        "title": "Verify account update with mismatched account number",
        "steps": [
          "Authenticate user session.",
          "Send a PUT request to /api/account/{accountNumber} with a mismatched account number in the payload.",
          "Check the response status code is 400 Bad Request."
        ],
        "expectedResult": "The system returns a 400 Bad Request error due to mismatched account numbers.",
        "businessRule": "Account transfers must validate sufficient funds before processing."
      },
      {
        "id": "FT4",
        "title": "Verify account deletion",
        "steps": [
          "Authenticate user session.",
          "Send a DELETE request to /api/account/{accountNumber} with a valid account number.",
          "Check the response status code is 204 No Content.",
          "Attempt to retrieve the deleted account and verify the response status code is 404 Not Found."
        ],
        "expectedResult": "The account is deleted successfully and cannot be retrieved.",
        "businessRule": "Transactions are logged with a unique sequence number for traceability."
      },
      {
        "id": "FT5",
        "title": "Verify fund transfer with insufficient balance",
        "steps": [
          "Authenticate user session.",
          "Initiate a fund transfer from an account with insufficient balance.",
          "Check the response status code is 400 Bad Request.",
          "Verify the response contains an error message indicating insufficient funds."
        ],
        "expectedResult": "The fund transfer fails with an error message due to insufficient balance.",
        "businessRule": "Account transfers must validate sufficient funds before processing."
      }
    ],
    "testStrategy": "The testing approach focuses on validating core banking functionalities such as account management, fund transfers, and transaction logging. Tests are designed to cover both positive and negative scenarios, ensuring compliance with business rules and regulatory requirements. Emphasis is placed on user authentication, data integrity, and security protocols.",
    "domainCoverage": [
      "Account Management",
      "Fund Transfers",
      "Transaction Logging",
      "User Authentication and Authorization",
      "Audit and Compliance"
    ]
  },
  "sourceLanguage": "COBOL",
  "targetLanguage": "C#",
  "databaseUsed": true,
  "analysisEnhanced": true,
  "architectureRecommendations": [
    "Clean Architecture",
    "Domain-Driven Design",
    "CQRS pattern",
    "MediatR for command/query handling",
    "Event sourcing for audit trails"
  ],
  "technologyStack": {
    "database": "Entity Framework Core with MySQL",
    "caching": "Redis",
    "messaging": "Azure Service Bus"
  },
  "enhancementContext": {
    "enhanced_context_used": true,
    "context_length": 1360,
    "analysis_available": true,
    "comprehensive_analysis": true
  }
}